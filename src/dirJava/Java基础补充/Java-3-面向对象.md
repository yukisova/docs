# 面向对象

面向对象思想：将所要实现的功能抽象成用多个封装好的对象组成的。是模块化思想的细分  
面向对象三大特征：
- 封装（将零散数据与行为封装为整体，面向对象的基础）
- 继承（将具有相同特征的封装进行归类，多态的前提）
- 多态（对象的多种形态）

## 封装
面向对象思想主要由class体系实现，即一个封装类，通俗的说将对象代表的事物封装在一个类中，类中包含着一下五类东西
- 成员变量：看成是一个类的特定属性
- 成员方法：看成是一个类的特有行为
- 构造方法：一个类的初始化方法
- 代码块：
- 内部类：

### 权限修饰符
权限修饰符可以看成是对应类、方法、属性的安全等级。一个java文件可以定义多个class类，但有且只有一个类被public修饰，而且对应类必须与文件名对应。因此不应该一个文件多个类。（一般只会使用public和private）
为了提高安全性，一般以bean类方式编写调用类，即对大部分参数使用get，set方法进行操作
- `public`：共有，代表该部分只要导入对应的包就可以调用
- `protected`：受保护，该部分无法被包以外的语句调用（在不同包中定义的子类可以使用）
- 空缺：默认,该部分无法被包以外的语句调用
- `private`：私有，只有在类里面的语句才能够调用

### this关键字
this关键字本质上是类自身的地址值，因此在类方法语句中可以通过this关键字调用到类自身的私有变量，在避免重名形参干扰的同时，还可以与修饰符结合，构成javabean类思想。提高代码安全性。或者可以这么说，this能够区分全局变量和局部变量

### 构造方法
即为与类名称相同的，无返回值类型标识的方法，通过构造方法，一个类可以正式看做一个对象，并由其他方法调用，一个类默认使用空参构造方法，可以重写来在创建对象时进行更多操作，也拥有重载特性。

```java
public class Phone{
    private String name;
    private double price;

    public Phone(){}
    public Phone(String name,double price){}

    public void setInfo(String name,double price){
        this.price = price;
        this.name = name;
    }
    public String getName(){
        return this.name;
    }
}
```

### 内存中的类
class文件加载时，对应的类声明与其中的方法声明与属性声明，进入**元空间**内存  
类中的方法运行时，语句逐行进入**栈**内存  
在方法语句中new出的对象的真实数据进入**堆**内存

### 类的种类
- JavaBean类：面向对象思想中描述一类事物。比如学生管理系统中的学生
  - 要保证安全性，因此要利用get set思想
  - 要公有化构造方法，用于创建对象
- 测试类：检查其他类是否书写正确，带有main方法，是程序的入口
- 工具类：定义一类工具，可以类比为vue中的计算属性，做一些特定事情，但不描述任何事物
  - 要保证类名对应一系列特定的操作
  - 要私有化构造方法，因为创建工具类的对象没有任何意义

## 静态-static
是一个独立于安全修饰符的特殊修饰符，用于调用需要让类对象共享的属性与方法，除了用类对象.的方式引用外，还可以直接通过类名.的方式引用。  
字节码文件在需要加载的时候，其中被static修饰的属性值会单独进入堆内存中的一处专门开辟的*静态存储区*。  
字节码文件所对应的对象被创建时，堆内存中对象的真实数据都会顺带指向静态存储区中的静态值，实现共享。  

### 静态属性
静态属性简要来说就是可以被所有类对象共享的属性，属于类本身而不单单属于某一个对象。  
总结：
- 被类所有对象共享
- 准确来说不属于对象，而属于类
- 随着类加载而加载，先于类对应对象存在
```java
// Stu类中的TName为静态属性
Stu.TName = "abc";
Stu a = new Stu();
Stu b = new Stu();
// 此时a.TName == b.TName
```
### 静态方法
总结：
- 用于测试类和工具类。
- 只能访问静态变量与其他静态方法。而且不能使用this关键字
  - this指向的是方法调用者（也就是对象）的地址，每个对象对应的this不同。静态代表着共享，因此this在静态方法中有根本性的冲突
  - this实际上是非静态方法中由虚拟机赋值的隐藏参数。


## 继承
封装实现了一定的复用，但是很多时候，类与类之间存在共性的内容，为了简化代码，可以将具有相同特征的封装进行父子关系的归类。  
实现：`extends`  
java继承特性：支持单继承与多层继承，不支持多继承，所有类都有一个直接间接的父类Object  
功能： 
- 将多个子类中重复代码抽取到父类，提高复用性
- 子类在父类基础上，增加其他功能，使其更加强大
```java
public class Student extends Person{}
```

### 子类继承的内容
- 构造方法：不管私有还是非私有，都不继承（继承的构造方法无法满足构造方法本身的法则）  
> 父类中的方法虽然不会被继承，但是子类为了能够使用父类中的元素，会默认先访问父类的无参构造完成父类初始化，再执行自身的构造函数。  
> 对应的父类构造函数为super()，JVM默认添加且只能添加在子类第一行  
> 若要访问父类有参构造，则需要手动写super函数对父类有参构造函数进行调用
- 成员属性：不管私有还是非私有，都继承（严格意义上，父类是将自己所有的属性拷贝给子类，自然子类也会有对应私有属性，但父子类的同名同类私有属性本质上是两个东西）
- 成员方法：在虚方法表中可以继承，否则不可继承（利用虚方法表概念，将满足虚方法的方法进行继承）    
> **虚方法表**：虚方法，即为未被private、final、static关键字修饰的方法。虚方法可以被子类继承这些虚方法表可以被子类继承，子类也可以基于父类的虚方法表加入自身新增的虚方法。方便系统查询并在此基础上实现方法重写。

### 方法重写
问题提出：很多时候，父类方法无法满足子类需求，需要根据子类具体的需求进行方法重写
重写方式：在子类中进行类似方法重载的操作，但与重载不一样，重写的方法要在其前添加`@Override`注解，用于校验子类重写时的语法是否正确，若语法错误会自动出现波浪线  
重写结果：虚方法表中的父类方法会被重写后的方法覆盖，本质上方法重写对象就是虚方法表  
```java
@Override
public void a(){}
```
重写注意事项：  
- 重写方法名与形参列表和被重写方法一致
- 重写方法权限尽量与被重写方法一致
- 只能重写虚方法表中的方法
::: info 注解和注释
注释是给开发者看的，而注解是给JVM看的，可以提升代码的安全性，并且提高可读性。
:::

### super关键字
this指向本类的成员，而super则直接指向父类的成员，在方法重写的时候，super关键字可以越过本类的同名方法调用父类的方法，即使用父类的虚方法表  
JVM会默认添加super()类，用于初始化父类的所有元素，也因此子类所访问到的父类元素取决于调用的是那种父类构造函数  


## 多态
基于继承，父类实际上可以接受子类的所有信息，因此可以实现多态来简化代码与提升扩展性。  
```java
// 不使用多态特性的话，
public void register(Son1 s){}
public void register(Son2 s){}
public void register(Son3 s){}
...
```
实现：`Father p = new Son()`  
其中Father是Son的父类，即父类对象可以new子类对象，实现父类的，因此上面的示例可以简写为
```java
// 这是测试类中的语句，实现父类指向子类对象
Father s = new Son1();
// 工具类中定义的函数，为了成功实现多态，每个子类中的父类方法需要重写
public void register(Father s){}
```
多态前提：
- 有继承/实现关系
- 父类引用指向子类对象
- 子类中方法必须重写  

### 多态时调用  
虽然多态可以让父类拥有自身子类的特性，但他本质上还是父类对象，因此在调用与子类冲突的属性和方法时，遵循以下原则：
调用属性：编译看父类，运行也看父类  
> 多态只是继承的一种衍生特性，父类无权调用子类特有属性，对于子类重新定义的继承属性，系统以父类为基准。
调用方法：编译看父类，运行看子类  
> 针对子类特有的方法，父类无权调用，但是子类重写的父类方法，系统调用时会以子类为基准，这也是多态要求子类重写父类方法的重要原因。  

### 调用原则带来的弊端
因为多态的父子调用原则，多态下的属性不能调用子类的特有功能  
解决方案：使用强制类型转换，将父类转换为子类（重要前提就是强制转换的双方有父子关系），而且不能乱转，一般要配合**instanceof三目运算符（jdk14）**与if判断  
`a instanceof b c`：判断a是否属于类型b，如果不属于就强制转换类型为b并赋值给c
```java
public void eat(Father a){
    if(a instanceof Son1 b){
        b.method1();
    }else if(a instanceof Son2 c){
        c.method2();
    }
}
```

## 最终-final
与static定位相似的修饰符，作用与其他语言中的const类似。被修饰的元素将不能被改变  

### 最终类
标明该类不能被继承，是父子体系的终点  
### 最终变量
标明该变量为常量，只能被赋值一次（引用数据类型对应的真实数据可以改变，因为不能重新赋值的是指向地址）
### 最终方法
标明该方法为不能被重写

## 面向对象补充
### 包
包package是在class之上的，以目录形式呈现的封装，管理不同功能的java类，方便代码维护。  
包名规则：域名反写+包的作用，全部英文小写  
使用除lang以外的包都需要先行导包，使用本包内的类不用导包  

### 代码块
代码块分为三个种类
- 局部代码块（写在方法位置）：其中定义的局部变量在出了代码块后便会自动销毁，主要用于节约内存（越来越没必要）
- 构造代码块（写在成员位置）：将多个构造方法中重复的代码抽取出来，在创建类对象时先执行构造代码块，节约代码（越来越没必要，很容易被this方法代替）
- 静态代码块（用static关键字修饰）：随着类的加载而加载，自动触发，只执行一次，做数据初始化。

## 抽象-abstract
问题提出：多态特性要求在子类中重写方法，来满足不同的子类有不同的方法特性，但是这并不是强制性的。而现实情况是，被抽取到父类的共性方法因为子类执行的内容不一样，在父类中无法确认具体的方法语句，否则逻辑上有巨大问题。  
`abstract`是用于修饰类和方法的修饰符，被修饰的方法只起到声明的作用；被修饰的类用于继承，实现规范化的父子归类。  
- 抽象类：如果一个类中存在哪怕一个抽象方法，那么该类就必须要声明为抽象类。
- 抽象方法：必须写在抽象类中，写法类比为函数声明：  
```java
public abstract void method();
```
被抽象的方法并没有在父类中给出具体方法体，必须在子类中进行重写，否则报错。  

### 注意点
- 抽象类不能被实例化。但可以有构造方法
  - 构造方法用于让子类对其进行初始化，获取其中的非抽象元素。
- 有抽象方法的类必须得是抽象类，抽象类中不一定非要有抽象方法。
- 抽象类的子类要么也是抽象类，若是实例化类必须要重写所有的抽象类。

## 接口-interface
问题提出：传统的父子体系是一对多的关系，部分子类拥有特征相同的功能，但不可能由父类将这些零散的功能总结起来。
> 动物类是青蛙、狗、兔子的父类，但只有青蛙和狗会游泳，因此不能将游泳功能加入到父类中。  
`interface`特点与抽象相似，但严格意义上是一种零散的规则，不能抽象一样作为父类，只能像插件一样插到类中  
上例创建了一种接口，他和类之间是实现关系，本身不能被实例化，必须要由类实现。被实现的接口性质与被继承的抽象类相似。
- 一个类可以实现多个接口
```java
public class Class implements Inter1,Inter2{
    // 重写接口中的所有抽象方法
}
```
- **重点：接口与接口之间是继承关系，而且可以多继承**
```java
public interface Inter extends Inter1,Inter2{
    // 里面写各种方法
}
```
- 实现时必须要重写所有接口包括继承关系的所有抽象方法，除非实现接口的是抽象类
- 接口中不一定非要有抽象方法。
  1. 为了方便接口升级，有默认方法的概念，这种方法可以有方法体。不强制重写，但如果要重写，必须要去掉default关键字
     - 但如果实现的多个接口中有同名的默认方法，必须要对默认方法重写，否则会报错
  2. 为了让接口的灵活性更高，可以定义静态方法。但接口中的静态方法只能通过接口名调用，并且**不能重写**
  3. 接口中可以定义私有方法，普通私有方法只对接口中的默认方法服务。静态私有方法只对接口中的静态方法服务
```java
public default void DefaultInterfaceMethod(){
    PrivateInterfaceMethod();
}
public static void StaticInterfaceMethod(){
    PrivateStaticInterfaceMethod();
}
private void PrivateInterfaceMethod(){}
private static void PrivateStaticInterfaceMethod(){}
```

### 接口中成员
- 成员变量：只能是常量 默认修饰符：`public static final`
- 构造方法：没有
- 成员方法：针对没有方法体的方法默认修饰符：`public abstract`

### 接口多态
当一个方法的参数是接口时，可以传递接口**所有实现类**的对象，称为接口多态  
`Inter a = new Class();`
```java
public void methodO(Inter a){
    // 这里写的接口对象实际上不可能指向接口，而是指向接口的任意实现类
}
```

### 适配器设计模式
为了缓解接口与实现类必须重写这个定势条件，可以在接口与实现类之间加上一个适配器类InterfaceAdapter，适配器空重写接口的所有方法，并继承给最终的实现类，实现类便可以根据实际情况选择性重写方法了。

## 内部类
问题提出：类Class主要用来封装一类客观事物，但在客观事物中往往还包含着多种可以看成一个整体的小事物，例如汽车中的引擎信息与工作方式。

内部类：在一个类中再定义一个类。用来封装类中一组从属一个整体但本身又是另一个整体的事物。

### 特点
- 内部类单独出现没有任何意义。
- 内部类可以直接访问外部类的成员，包括私有成员。
- 外部类要访问内部类成员必须创建对象。

### 成员内部类
- 写在成员位置的内部类
### 静态内部类
- 用static修饰的内部类
- 只能访问外部类中的静态变量和静态方法，访问非静
### 局部内部类
- 在方法内部的内部类

### 匿名内部类
- 隐藏了名字的内部类，与创建对象语句结合，与匿名函数大同小异。用于简化对象实例化，不用专门设计子类或者接口实现类
- 格式包含的只有要实现的接口，与实例化的类。与对应的无参构造。
- 不能在实现接口的同时继承父类
```java
new 继承类名或实现接口名(){
    重写方法;
};
// 
```
