# Stream流操作

## 不可变集合
所谓的不可变集合，即为在集合的基础上，具有常量的特征：即不可修改。或者说，当该集合对象被不可信库调用时，能保证集合内容的安全。  
目的：不想让别人修改集合中的内容  
创建方式：使用集合List、Set、Map接口中存在的静态方法`of`，可以创建具有指定元素的对应集合对象  
当试图删除该集合对象的元素时，会报错
```java
List<String> list = List.of("张三","李四");
// Map.of方法最多只能传递20个参数，因此只能最多创建10个键值对
Map<String,String> map = Map.of("张三","3","李四","5");
// Map.ofEntries方法支持以Entry数组的形式传入多个键值对，由此可以创建10个以上的键值对
Map<String,String> map1 = Map.ofEntries(hashmap.entrySet().toArray(new Map.Entry[0]));
// Map.copyOf方法进一步简化了Map的of方法实现，通过迭代的方式将可变集合转化为不可变集合。
Map<String,String> map2 = Map.copyOf(hashmap);
// 
```

## 流-Stream
问题提出：对集合中的数据进行操作时对应的语句相对繁琐。  
思路：程序本身可以看成是一个流水线，容器（集合与数组）本身可以看成流水线上的流数据，而针对容器的操作其实可以看成是流的过滤，通过一次次过滤，获取最终的结果。也就是Stream流思想  
目的：结合Lambda表达式（匿名函数），简化容器的操作  
步骤：
1. 先得到一条Stream流，并将数据放上去
2. 利用StreamApi进行操作
   - 中间方法：过滤和转换——方法调用完毕后，还可以接着调用其他方法
   - 终结方法：统计和打印——方法调用完毕后，不可以继续调用其他方法

### 获取Stream流
- 针对集合：`单列集合对象.stream()`：是单列集合中的默认方法，双列集合必须要转换为单列集合才能获取到流水线
- 针对数组：`Arrays.stream(数组对象)`：是Arrays工具类中的静态方法，但要注意数组必须要是引用数据类型的，否则会将整个数组当做一个元素传递到流水线中
- 针对零散数据：`Stream.of(多个同类零散数据)`：是Stream接口中的静态方法，零散数据需要是同种数据类型

## 流中间方法
中间方法会返回新的Stream流，类似迭代器，一个流对象只能使用一次，因此建议链式编程  
修改Stream流中的数据并不会影响原本的容器
- 过滤：`.filter(lambda)`——匿名函数的返回值为布尔类型，为true则代表数据留下，false则代表数据被筛掉
- 获取元素：`.limit(获取元素数)`
- 跳过元素：`.skip(跳过元素数)`
- 去重：`.distinct()`——依赖Hashcode和equals，有可能需要重写以上两个方法
- 合并流：`.concat(流1,流2)`
- 转换流为双列集合：`.map(lambda)`——要依赖lambda表达式将值s扩展为完整的map

## 流终结方法
- 遍历：`.forEach(lambda)`
- 统计：`.count()`
- 流中数据放到数组：`.toArray()`
- 流中数据放到集合：`.collect()`

## 函数式接口——方法引用
所谓的方法引用，是Lambda表达式对应的函数式接口的扩展，将原本需要重写的匿名函数用一个已经存在的方法代替  
条件：
- 对应的形参必须是函数式接口
- 引用方法必须存在，且形参和返回值需要和函数式接口中抽象方法保持一致
- 引用方法的功能要满足当前需求
语法：`引用类或引用对象::引用方法`，以下为实例  
```java
// 在没有引入方法时，函数式接口要用以下形式扩展重写
Arrays.sort(arr, new Comparator<Integer>(){
    @Override
    public int compare(Integer o1, Integer o2){
        return o2 - o1;
    }
})

// 此时A类中存在这样一个静态方法
public static int subtraction(int n1,int n2){
    return n2 - n1;
}

// 方法引用
Arrays.sort(arr, A::subtraction)
```

### 方法引用分类
:: tabs 
@tab 静态方法
**格式**：`类名::静态方法`
@tab 成员方法
**格式**：`对象::成员方法`
1. 针对其他类：`其他类对象::方法`
2. 针对本类：`this::方法`
3. 针对父类：`super::方法`
@tab 构造方法
**格式**：`类名::new`
@tab 其他调用
::
### 函数式接口