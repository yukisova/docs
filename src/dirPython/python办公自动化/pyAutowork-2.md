# Excel自动化操作-pandas

## pandas-数据类型
pandas是一个专门用于操作数据表与sql语句的库，两者相同的点就是呈现形式都是行列交错的记录组成
openpyxl是用于构建xlsx文件的库
- DataFrame类的构造方法，可以构造出一个最基础的数据表对象。
```python
table = pd.DataFrame({
    '序号':[1,2,3],
    '姓名':['叶文','赵子龙','王建华']
})
```
为了与其他表构成关系，一般都需要指定一个字段为“索引”，如下例所示  
`table = table.set_index('序号')`  

上例定义了数据框架，可以使用以下三种方法在他们的基础上新建对应的文件
- csv/txt：`.to_csv()`
- excel：`.to_excel()`
- sql：`.to_sql()`
  
## pandas-读取文件
问题提出：excel文件在处理量级巨大的数据表时非常吃力，因此在实际操作中，办公自动化针对的还是csv这样的纯文本文件，另外还有sql数据库文件
### 针对csv
csv文件主要通过分隔符来分割每列数据，为此有两种读取方法
```python
# 以table形式读取：默认分隔符为制表符Tab，如果需要修改分隔符要设置sep参数
data = pd.read_table(路径,sep='分隔符')

# 以csv形式读取：默认制表符为逗号,
data = pd.read_csv(路径)
```
当一个csv文件中需要使用多种分隔符来分割，最好使用正则表达式（工具），要导入re库  
问题提出：打印信息的时候系统会将第一个记录当成表头。为了处理诸如此类的情况要额外在读取时指定方法的参数
- sep：分隔符设置，或者正则表达式
- header：列名所在的行号，默认为0，一般都由用户指定列名，要设为None
- names：列名列表，与header=None配合使用。
- index_col：记录索引所在的字段列表，默认没有，自动指定从0开始
- skiprows：读取时要跳过的行数或行号列表
- encoding：文件编码
- nrows：在print时显示的行数，用于代替.head()方法

### 针对sql
pandas针对数据库的读取，要与pymysql这样的数据库包结合使用，在利用pymysql已经建立好了数据库链接对象的情况下，可以使用如下语句读取数据库中的指定数据表
```python
data = pd.read_sql("sql语句",con=链接对象)
```

### 针对excel
excel表的操作，pandas还要与xlrd和xlwt进行配合。通过如下方法来进行读取，除此之外，别的方面与csv大同小异
```python
data = pd.read_excel(路径)
```

## pandas-数据结构
pandas将一个独立的数据表分为了如下部分——DataFrame和Series。
### Series
称为记录，一维结构，代表着一组信息，由两部分组成：列表形式排列的数据与对应的索引字段。
`se = Series([数据列表],index = [索引字段列表])`  
因为字段和数据有清晰的对应关系，可以使用字典类型简化定义  
`se = Series({字典类型值})`  
对应的访问方法：
- se.index ：返回索引字段列表
- se.values：返回数据列表
- se[[访问字段列表]]：访问选定的字段的数据  

### DataFrame
称为数据框图，二维结构，由多个记录Series组成，分为三个部分：即二维列表形式排列的多条记录数据与对应的列名列表(=索引字段列表)，以及用于标识记录的索引下标。同样可以用字典类型简化定义  
因为代表着二维结构，index此时不再对应字段，而用column代替，index用于标识记录
`df = DataFrame([[记录1数据],[记录2数据],...],columns=[列名列表])`
可以由Series组成，不过因为index和columns之间的不可调和性，字段列表会显示在左边（这也是索引列表称为列名列表作用相同含义分开的原因）
对应的访问方法：  
- df[列名][索引下标]：访问指定记录中对应字段的数据
- df.loc[索引下标][列名]：与上述相同，只是引用格式不同
  - df.loc[索引下标:结束下标]：从指定下标开始，返回一定范围内的记录，不包括结束下标记录
- df.iloc[r][c]：类比为xlsx中的r1c1模式
常用方法：
- `df.fillna('填充值')`：为空单元格填充指定值
- `df.dropna()`：删除空单元格
- `df.head(行数)`：显示从第一行开始数指定行数的记录，另外还有`.tail()`
- `df.replace(目标值,替换值)`：将框图内指定的值给替换为另一个值
- `df.unique()`：查看唯一值
- `df.shape` ：以元祖形式返回行列数- 例如结果`(1,1)`代表数据表有1行1列
- `df.columns`：列名列表，对应的行不会被index记录。可以赋值列表来确定列名
- `df.index`：显示索引下标信息
- `df.dtypes`：查看每一个字段的数据类型
- `df.isnull()`：另外还有`notnull()`，判断值是否为空
- `df.reset_index(drop=True)`：删除或还原索引列（drop=false将索引列还原位普通列，drop=true删除索引列）
- `df.sort_index()`：按照索引排序
- `df.sort_values('字段')`：基于指定的字段值排序



- `pd.pivot.table(数据)`：基于df做数据透视表

## 连接查询-merge(只有很小一部分)
数据表中的连接查询与sql大同小异，分为内连接与左右连接，实现连接查询的方法为`pd.merge()`
参数如下：
- 数据1和数据2
- on：连接查询基于字段或指定字段列表
- how：查询方式
  - inner：内连接，默认值，左右表的交集
  - left：左外连接 基于左表
  - right：右外连接 基于右表
  - outer：全外连接 将表的所有部分都包含起来
  
- left_on = 左表连接字段
- right_index = 是否连接到右表的索引列 (与left_on配合实现基于右表索引列的链接)

- suffix：后缀参数，当表合并的过程中遇到一列两个表重名，但是值不同，合并时又想保留，该参数为重复列名添加后缀

## 连接查询-join
`左表.join(右表,on='字段',lsuffix='前缀',rsuffix='后缀',)`  
按列合并，可以递增合并多个表

## 连接查询-concat
`pd.concat([数据1，数据2])`  
默认情况下就是按照行合并

